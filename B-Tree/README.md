B-Tree
=====

什么是B树？
---------------

From [维基百科](http://zh.wikipedia.org/wiki/B%E6%A0%91):B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。

定义
--------
根据Knuth的定义，一棵m叉B树，需要同时满足以下条件：

1. 每个节点之多有m个孩子节点。
2. 除了叶子节点和根节点，其余节点至少有ceil(m / 2)个孩子节点。
3. 如果根节点不是叶子节点，则至少有两个孩子节点。
4. 非叶子节点如果有k个孩子，则有k-1个关键字。
5. 所有的叶子节点处于同一层。

查找
----

查找算法类似于二查搜索树查找，从根节点开始向下递归查找。

定义insertIndex为关键字不存在时应该插入的索引位置，index为关键字存在时的索引位置。

由二分查找算法
```java
int binarySearch(T key) {
	int low = 0;
	int high = size - 1;
	while (low <= high) {
		int mid = (low + high) >>> 1;
		int cmp = cmp(key, (T)values[mid]);
		if (cmp == 0)
			return mid;
		if (cmp < 0) {
			high = mid - 1;
		} else {
			low = mid + 1;
		}
	}
	return -(low + 1);
}
```
若关键字存在，返回关键字的位置，否则low即为需要插入的位置，根据返回的值x，-x-1即为insertIndex的值。

查找算法：

1. 初始化p = root, key
2. 若p是叶子节点，调用index = p.binarySearch(key), 若index >= 0, 返回true， 否则返回false。
3. p不是叶子节点，调用index = p.binarySearch(key)， 若index >= 0,返回true，否则转4步。
4. 求插入位置insertIndex = -index - 1; 令p = p.children[insertIndex], 转2.

插入
----

必须插入关键字在叶子节点上，不能直接插入到非叶子节点中。首先根据查找算法查找需要插入的叶子节点位置，若关键字已经存在，直接返回，否则插入到叶子中，然后判断叶子是否满了，若满了需要分裂节点。

插入算法：

1. 根据查找算法，找到插入的位置，若关键字已经存在，算法结束。否则转2。
2. 把关键字插入到叶子中，并保持关键字有序。若此时叶子节点关键字数量不超过最大数量，算法结束。否则转3。
3. 从叶子节点中抽出中间节点mid 。
4. 把叶子节点由mid平均分隔成两个节点，其中比mid小的关键字位于左节点，比mid大的位于右节点。
5. 更新左节点和右节点孩子节点的父亲节点，指向左节点或右节点。mid父亲节点指向父亲的父亲节点。
6. 若mid的父亲节点存在，把mid节点插入到父亲节点中，mid的两边孩子分别指向左节点和右节点。若不存在父亲节点，新建一个节点作为父亲节点，并把mid插入。
7. 若parent节点也满了，递归分裂parent节点，直到所有节点都满足条件。

删除
----

删除关键字的步骤是先定位关键字，然后删除，最后调整使其满足b树特征。

删除位置可能是叶子节点或者是内部节点。

1. 在叶子上删除。
  + 定位关键字，删除。
  + 如果该节点关键字数量少于最少数量，重新调整。
2. 在内部节点上删除。由于内部节点的每个关键字都作为两颗子树的分隔符，因此删除后，必须寻找新的分隔符。左子树的最大节点和右子树的最小节点都可以作为新的分隔符。
  + 从左子树中的叶子中找到最右关键字作为分隔符，若左子树不存在，寻找右子树最左关键字作为分隔符。将分隔符从叶子中移到删除关键字的位置。
  + 如果从叶子中移除了分隔符后，剩余关键字数量少于最少关键字数量，重新调整。

删除节点后调整
-------------
1. 如果贫困节点的右兄弟节点富裕，即多于最少节点，则左旋转。
  + 把父亲节点的分隔符关键字移到贫困节点末尾。此时贫困节点顺利脱贫。
  + 把右兄弟节点的第一个节点取代原来分隔符关键字位置。右兄弟节点依然富裕。
  + 树已经达到平衡，结束。
2. 否则若贫困节点的左兄弟富裕，则右旋转。
  + 把父亲节点的分隔符关键字插入到贫困节点的首位置。此时贫困节点顺利脱贫。
  + 把左兄弟的最后一个节点取代分隔符关键字原来的位置。
  + 树已经达到平衡，结束。
3. 否则，由于左兄弟和右兄弟都不富裕，需要合并操作。
  + 定义左节点为: 若存在右兄弟，则左节点为贫困节点，否则为贫困节点的左兄弟。
  + 定义右节点为：左节点的右兄弟。
  + 将分隔符关键字移到左节点（可能是贫困节点或者刚好等于最少数量的节点）的最后位置，父亲节点关键字数减一。
  + 把右节点的所有信息拷贝到左节点（包括孩子也要拷贝），此时左节点达到最大关键字数量，释放右节点。
  + 由于父亲节点关键字数少一：
    - 若父亲节点是root并且此时为空，释放该节点，并把root指向新合并的节点（左节点）。此时高度-1.
    - 若父亲节点是root，无需调整。
    - 否则若父节点关键字数量少于最少节点，递归调整父亲节点。
