洗牌算法
========

我们可能接触比较多的一种情况是需要把一个无序的列表排序成一个有序列表。洗牌算法（shuffle）则是一个相反的过程，即把一个有序的列表（当然无序也无所谓）变成一个无序的列表。

这个新列表必须是随机的，即原来的某个数在新列表的位置具有随机性！

我们假设有1～100共100个无重复数字。

方案一
======

从第一张牌开始，利用随机函数生成器产生1～100的随机数，比如产生88,则看第88个位置有没有占用，如果没有占用则把当前牌放到第88位置，如果已经占用，则重新产生随机数，直到找到有空位置！

首先必须承认这个方法是可以实现洗牌算法的。关键在于效率，首先空间复杂度是O(n)，时间复杂度也是O(n)，关键是越到后面越难找到空位置，大量时间浪费在求随机数和找空位置的。

方案二
======

从第一张牌开始，设当前位置牌为第i张，利用随机函数生成器产生1～100的随机数，比如产生88，则交换第i张牌和第88张牌。
这样满足了空间是O（1）的原地操作，时间复杂度是O(n)。

但是否能够保证每个牌的位置具有机会均等性呢？

首先一个常识是：n张牌，利用随机数产生N种情况，则必须满足N能够整除n，这样就能给予每个牌以N/n的机会（或者说权值），如果N不能整除n，必然机会不均等，即有些牌分配的机会多，有些少。

我们知道100的全排列有100的阶乘种情况，而调用100次随机函数，共可以产生100^100种情况，而n^n 必然不能整除n!，具体证明不在这里叙述。
方案三
======

那我们可以利用第二种方法改进，每次不是产生1~100的随机数，而是1~i的数字，则共有n!中情况，即N=n!，显然满足条件，且时间为O(n),空间为O(1).这也就是Fisher-Yates_shuffle算法，java.util.Collections.shuffle即是使用该方法。 

我们知道100的全排列有100的阶乘种情况，而调用100次随机函数，共可以产生100^100种情况，而n^n 必然不能整除n!，具体证明不在这里叙述。
